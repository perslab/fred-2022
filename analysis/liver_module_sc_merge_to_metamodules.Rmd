---
title: 'Liver - merge gene modules based on co-expression and shared correlations with disease status in bulk (Gerhard) '
author: "Jon Thompson, Pers lab, rkm916 at ku dot dk"
date: "`r Sys.time()`" 
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
params: 
  date: !r substr(gsub("-","",as.character(Sys.Date())),3,1000)
  randomSeed: !r 12345
  pValThreshold: !r 0.05
  pAdjMethod: "BH"
# output:
#   html_notebook:
#     df_print: paged
#     number_sections: yes
#     toc: yes
#     toc_depth: 3
#     toc_float: yes
#   html_document:
#     df_print: paged
#     number_sections: yes
#     toc: yes
#     toc_depth: 3
#     toc_float: yes
---

# Setup

## Load packages

```{r}
#ipak(c("Seurat", "dplyr", "ggplot2", "Matrix", "parallel", "readr", "tidyr"))
#library("Seurat")

library("data.table")
library("Matrix")
library("parallel")
#library("tidyverse")
#library("AUCell")
library("here")
library("boot")
library("magrittr")
library("WGCNA")
library("cluster")
# source utility functions

source(here("/perslab-sc-library", "utility_functions.R"))
source(here("perslab-sc-library", "functions_sc.R"))

# Set options

options(stringsAsFactors = F, 
        use="pairwise.complete.obs", 
        warn=1, 
        verbose=F,
        boot.parallel="multicore", # see ?boot: each worker process inherits the environment of the current session, including the workspace and the loaded namespaces and attached packages (but not the random number seed: see below). 
        boot.ncpus = 20,
        mc.cores=40 # for parallel computation
        ) 

RNGkind("L'Ecuyer-CMRG")
# ?boot
# For most of the boot methods the resampling is done in the master process, but not if simple = TRUE nor sim = "parametric". In those cases (or where statistic itself uses random numbers), more care is needed if the results need to be reproducible. Resampling is done in the worker processes by censboot(sim = "wierd") and by most of the schemes in tsboot (the exceptions being sim == "fixed" and sim == "geom" with the default ran.gen).
# 
# Where random-number generation is done in the worker processes, the default behaviour is that each worker chooses a separate seed, non-reproducibly. However, with parallel = "multicore" or parallel = "snow" using the default cluster, a second approach is used if RNGkind("L'Ecuyer-CMRG") has been selected. In that approach each worker gets a different subsequence of the RNG stream based on the seed at the time the worker is spawned and so the results will be reproducible if ncpus is unchanged, and for parallel = "multicore" if parallel::mc.reset.stream() is called: see the examples for mclapply. 

# data.table
setDTthreads(threads = NULL, 
             restore_after_fork = NULL)
getDTthreads()

# Set constants

randomSeed = 12345
set.seed(randomSeed)
flagDate =substr(gsub("-","",as.character(Sys.Date())),3,1000)

#distmethod = "euclidian"
hclustmethod = "average"

# generic project constants 

prefixData = "liver_perslab_int"
prefixRun = "seurat_7"
prefixRun_WGCNA = "wgcna3"

dirWGCNA_outs = "/projects/jonatan/pub-perslab/18-liver-wgcna/"
dirWGCNA_plots = paste0(dirWGCNA_outs, "plots/" )
dirWGCNA_RObjects = paste0(dirWGCNA_outs, "RObjects/" )
dirWGCNA_tables = paste0(dirWGCNA_outs, "tables/" )

colGeneWeights = "pkMs"
colGeneNames = "genes"
colModule = "module_renamed"
colCellCluster = "cell_cluster_pres"
# naming convention:
# <prefixData>_<prefixRun>_<prefixOut>_<outputType>_<params>_<params>_..._<date>.pdf

```

## load data

load data.table with information on module and cell type of origin

```{r}
path_geneMod_perslab<- paste0(dirWGCNA_tables,prefixData, "_",prefixRun_WGCNA,"_geneMod.csv.gz")
dt_geneMod_perslab <- fread(path_geneMod_perslab)
#head(dt_geneMod_perslab)

# path_geneMod_gerhard2018 <- paste0(dirWGCNA_tables,"liver_gerhard2018_wgcna3_geneMod.csv.gz")
# dt_geneMod_gerhard2018 <- fread(path_geneMod_gerhard2018)
# #head(dt_geneMod_gerhard2018)

# path_geneMod_moylan2013 <- paste0(dirWGCNA_tables,"liver_moylan2013_wgcna1_geneMod.csv.gz")
# dt_geneMod_moylan2013 <- fread(path_geneMod_moylan2013)
# #head(dt_geneMod_gerhard2018)
```

```{r}
# dt_geneMod_merged = rbindlist(list(dt_geneMod_perslab,dt_geneMod_gerhard2018, dt_geneMod_moylan2013))
# 
# dt_geneMod_merged[[colModule]] %>% unique -> vec_mods
dt_geneMod_perslab[[colModule]] %>% unique -> vec_mods

vec_mods <- vec_mods[!is.na(vec_mods) & nchar(vec_mods)>0]
```

# analysis

```{r}
df_scaled_embed = fread("/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_mat_scaled_embed_gerhard2018.csv.gz") %>% setDF

mat_scaled_embed = df_scaled_embed[,-1] %>% as.matrix
rownames(mat_scaled_embed) = df_scaled_embed$run_accession
mat_scaled_embed[0:4,0:4]

```

get overlap matrix

```{r}
# dt_geneMod_perslab[[colModule]] %>% unique -> vec_mods
# 
# vec_mods <- vec_mods[!is.na(vec_mods) & nchar(vec_mods)>0]

list_genelists = lapply(vec_mods, function(mod) {
  condition = quote(dt_geneMod_perslab[[colModule]]==mod)
  vec_mod_genes = dt_geneMod_perslab[eval(condition), ..colGeneNames, ][[1]] %>% unique
  # filter out moduke genes absent in expression data
  #vec_idxRow <- match(vec_mod_genes, dt_datExpr[,gene])
  #vec_mod_genes <- vec_mod_genes[!is.na(vec_idxRow)]
  return(vec_mod_genes)
})

names(list_genelists) = vec_mods
```

the intersect matrix tells you how big a proportion of the row module's genes are also in the column module

```{r}

# outer loop is columns, inner is rows
fun = function(genelist) {
    sapply(list_genelists, function(genelistOther) {
      base::intersect(x=genelist, y=genelistOther) %>% length %>% '/'(length(genelist))
    }, simplify=T)
  }
  
mat_moduleGeneIntersect <- sapply(FUN=fun,"X"=list_genelists, simplify = T)

mat_moduleGeneIntersect[row(mat_moduleGeneIntersect)==col(mat_moduleGeneIntersect)] <- 0 
#<- mat_moduleGeneIntersect-diag(1, nrow=nrow(mat_moduleGeneIntersect))
```

```{r}
summary(as.numeric(mat_moduleGeneIntersect))

#     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
#   0.00000 0.00000 0.00000 0.07862 0.02247 0.95833
```

<!-- ```{r} -->
<!-- mat_scaled_embed <- mat_sc_mod_embed_gerhard2018[,colnames(mat_sc_mod_embed_gerhard2018) %in% dt_geneMod_perslab[[colModule]]] -->
<!-- ``` -->

### cluster and merge modules

scale module embeddings to sum to 1, then make euclidian distance matrix 

<!-- ```{r} -->
<!-- mat_scaled_embed_rescaled = apply(mat_scaled_embed, 2, FUN=function(eachcol) eachcol/sum(eachcol)) -->
<!-- ``` -->

```{r}
mat_scaled_embed_sc <-  mat_scaled_embed[,!grepl("gerhard", colnames(mat_scaled_embed))]
```

```{r}

mat_cor <- cor(mat_scaled_embed_sc, use="pairwise.complete.obs")
mat_cor[mat_cor<0] <- 0
mat_dist <- as.dist(1 - mat_cor)
# computes the distance between the *rows*
#mat_dist <- dist(x=t(mat_scaled_embed_rescaled), method = distmethod)

```

hiearchical clustering 

```{r}
hclustTree = hclust(d=mat_dist, method=hclustmethod)

list_cutree = lapply(0:4, function(deepSplit) cutreeHybrid(dendro = hclustTree, 
                       distM = as.matrix(mat_dist),
                       minClusterSize = 1,
                       deepSplit=deepSplit, 
                       pamStage=T,
                       pamRespectsDendro=T,
                       verbose=T))
```

compute silhouettes

```{r}
vec_sil_mean = sapply(list_cutree, function(cutree) {
  n_singletons = sum(cutree$labels==0)
  vec_singleton_labels = (max(cutree$labels)+1):(max(cutree$labels)+n_singletons)
  vec_metalabels = cutree$labels
  vec_metalabels[vec_metalabels==0] = vec_singleton_labels

  sil_mean = cluster::silhouette(x = vec_metalabels, dist=mat_dist)[,3] %>% mean
})

vec_sil_mean 
# [1] 0.6741432 0.6483593 0.6596748 0.7011363 0.7011363
```

using deepSplit=3 or 4 gives the best mean silhouette

but it's not very different from deepsplit = 0, which will eliminate more overlaps between modules

```{r}
cutree= list_cutree[[1]]
```

```{r}
n_singletons = sum(cutree$labels==0)
vec_singleton_labels = (max(cutree$labels)+1):(max(cutree$labels)+n_singletons)
vec_metalabels = cutree$labels
vec_metalabels[vec_metalabels==0] = vec_singleton_labels

vec_mods = hclustTree$labels
names(vec_mods) = paste0("metamodule_",vec_metalabels)

#vec_mods[order(names(vec_mods))]

vec_mods_meta = sort(unique(names(vec_mods)))
vec_mods_meta <- vec_mods_meta[order(as.numeric(gsub("metamodule_","",vec_mods_meta)))]
vec_mods_meta
```

### add new metamodule labels to module data tables

```{r}
dt_geneMod_perslab$module_meta = names(vec_mods)[match(dt_geneMod_perslab[[colModule]], vec_mods)]

dt_geneMod_perslab$cell_cluster_meta = ifelse(!is.na(dt_geneMod_perslab$module_meta) & nchar(dt_geneMod_perslab$module_meta)>0,  dt_geneMod_perslab[[colCellCluster]],NA_character_)
```


<!-- ```{r} -->
<!-- dt_geneMod_gerhard2018$module_meta = names(vec_mods)[match(dt_geneMod_gerhard2018[[colModule]], vec_mods)] -->

<!-- dt_geneMod_gerhard2018$cell_cluster_meta = ifelse(!is.na(dt_geneMod_gerhard2018$module_meta) & nchar(dt_geneMod_gerhard2018$module_meta)>0,  dt_geneMod_gerhard2018[[colCellCluster]],NA_character_) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- dt_geneMod_moylan2013$module_meta = names(vec_mods)[match(dt_geneMod_moylan2013[[colModule]], vec_mods)] -->

<!-- dt_geneMod_moylan2013$cell_cluster_meta = ifelse(!is.na(dt_geneMod_moylan2013$module_meta) & nchar(dt_geneMod_moylan2013$module_meta)>0,  dt_geneMod_moylan2013[[colCellCluster]],NA_character_) -->
<!-- ``` -->

# Do meta modules still overlap?

get list of vectors of gene weights with gene names (weights aren't used, just for backward consistency)

<!-- ```{r} -->
<!-- dt_geneMod_perslab = rbindlist(list(dt_geneMod_perslab, dt_geneMod_gerhard2018, dt_geneMod_moylan2013)) -->
<!-- ``` -->

```{r}
list_geneWeights_meta = lapply(vec_mods_meta, function(mod_meta) {
    vec_out =dt_geneMod_perslab[[colGeneWeights]][dt_geneMod_perslab$module_meta==mod_meta] 
    names(vec_out) <- dt_geneMod_perslab[[colGeneNames]][dt_geneMod_perslab$module_meta==mod_meta]
    return(vec_out)
  })

names(list_geneWeights_meta)=vec_mods_meta

# outer loop is columns, inner is rows
mat_overlap_meta = sapply(list_geneWeights_meta, function(geneWeights) {
    sapply(list_geneWeights_meta, function(geneWeightsOther) {
      base::intersect(x=unique(names(geneWeights)), y=unique(names(geneWeightsOther))) %>% length %>% '/'(length(unique(names(geneWeights))))
    }, simplify=T)
  })

mat_overlap_meta[row(mat_overlap_meta)==col(mat_overlap_meta)] <- 0
```

```{r}
max(mat_overlap_meta, na.rm = T)
# [1] 0.2061069
```

we see that the max gene overlap proportion for the meta modules is 0.23, so still high-ish, but it gives the best silhouette. Also it is in the ballpark of earlier iterations.

```{r}
col3 <- colorRampPalette(c("blue", "white", "red"))

pdf(file = paste0("/projects/jonatan/pub-perslab/18-liver-wgcna/plots/", prefixData, "_", prefixRun, "_", prefixRun_WGCNA, "_intersectplot_meta_modules_", flagDate,".pdf"), width = 6, height=4)

p <- corrplot::corrplot(mat_overlap_meta, 
                        is.corr = F,
                        method = "shade", 
                        col = col3(50),
                        #type = "lower", 
                        mar= c(5, 4, 1, 2), # c(bottom, left, top, right) 
                        diag = F, 
                        order = "original", 
                        tl.cex=0.7,
                        cl.cex=0.6,
                        cl.lim = c(0,1))

dev.off()
```


### visualise merged modules on correlation matrix with metamodule labels

### check module-module correlations

```{r}
mat_cor = cor(mat_scaled_embed_sc)
```

```{r}
all.equal(vec_mods, colnames(mat_cor))
# [1] "names for target but not for current"
```

```{r}
mat_cor_renamed <- mat_cor

colnames(mat_cor_renamed) <- rownames(mat_cor_renamed) <- paste0(names(vec_mods), "_", vec_mods)
```

```{r}
col3 <- colorRampPalette(c("blue", "white", "red"))

pdf(file = paste0("/projects/jonatan/pub-perslab/18-liver-wgcna/plots/", prefixData, "_", prefixRun, "_", prefixRun_WGCNA, "_corrplot_mod_metalabels_", flagDate,".pdf"), width = 20, height=26)

p <- corrplot::corrplot(mat_cor_renamed, 
                        method = "shade", 
                        col = col3(50),
                        type = "lower", 
                        diag = F, 
                        order = "hclust", 
                        mar = c(3, 3, 8, 3),
                        tl.cex=0.8)

dev.off()
```

<!-- ```{r} -->
<!-- dt_geneMod_gerhard2018_merged$module_meta = names(vec_mods)[match(dt_geneMod_gerhard2018_merged[[colModule]], vec_mods)] -->

<!-- dt_geneMod_gerhard2018_merged$cell_cluster_meta = ifelse(!is.na(dt_geneMod_gerhard2018_merged$module_meta),  dt_geneMod_gerhard2018_merged[[colCellCluster]],NA_character_) -->
<!-- ``` -->


### check how much modules assigned to a given meta-module overlap in terms of genes

```{r}
fun = function(geneWeights) {
  sapply(list_geneWeights, function(geneWeightsOther) {
    base::intersect(x=names(geneWeights), y=names(geneWeightsOther)) %>% length %>% '/'(length(geneWeights))
  }, simplify=T)
}
```

```{r}
list_mat_overlaps = lapply(vec_mods_meta, function(mod_meta) {
  
  vec_mods_in_mod_meta = vec_mods[names(vec_mods)==mod_meta]
  
  names(vec_mods_in_mod_meta) = NULL
  
  list_geneWeights = lapply(vec_mods_in_mod_meta, function(mod) {
    vec_out =dt_geneMod_perslab[[colGeneWeights]][dt_geneMod_perslab[[colModule]] ==mod] 
    names(vec_out) <- dt_geneMod_perslab[[colGeneNames]][dt_geneMod_perslab[[colModule]]==mod]
    return(vec_out)
  })
  
  names(list_geneWeights)=vec_mods_in_mod_meta
  
  mat_overlap = sapply(list_geneWeights, function(geneWeights) {
    sapply(list_geneWeights, function(geneWeightsOther) {
      base::intersect(x=names(geneWeights), y=names(geneWeightsOther)) %>% length %>% '/'(length(geneWeights))
    }, simplify=T)
  })
  
  return(mat_overlap)
})

names(list_mat_overlaps) = vec_mods_meta

```

```{r}
sapply(list_mat_overlaps, FUN = function(mat_overlap) mean(mat_overlap, na.rm = T))
```

Some meta-modules consist of highly overlapping modules, others are fairly distinct.

## compute meta-module embeddings

```{r}
mat_embed_meta = sapply(vec_mods_meta, function(mod_meta) {
  
  vec_mods_in_mod_meta = vec_mods[names(vec_mods)==mod_meta]
  # weight by number of genes
  vec_weights = sapply(vec_mods_in_mod_meta, function(each_mod) {sum(dt_geneMod_perslab[[colModule]]==each_mod)})
  vec_weights = vec_weights/sum(vec_weights)
  names(vec_weights) = vec_mods_in_mod_meta
  mat_tmp = mat_scaled_embed[,vec_mods_in_mod_meta]
  if (!is.null(dim(mat_tmp))) {
      # scale the columns of the embeddings matrix by number of genes and take the mean across modules
    mat_tmp = sapply(colnames(mat_tmp), function(each_mod) mat_tmp[,each_mod]*vec_weights[each_mod])
    mat_tmp %>% rowMeans
  } else { # if the metamodule has a single module
    mat_tmp
  }
})

mat_embed_meta[0:3,0:3]
```


```{r}
sd(mat_embed_meta[,1])

```

the metamodules have much lower variance than the modules. 
Scale metamodules to standard deviation 1 just for consistency

```{r}
mat_embed_meta <- scale(mat_embed_meta, center=F, scale= apply(mat_embed_meta, 2, sd, na.rm = TRUE)) 
```


```{r}
sd(mat_embed_meta[,1])
#[1] 1
```


### check meta-module - meta-module correlations

```{r}
mat_cor_meta = cor(mat_embed_meta)

mat_cor_meta[row(mat_cor_meta)==col(mat_cor_meta)] <- 0

vec_max_cor = sapply(1:nrow(mat_cor_meta), function(i) max(mat_cor_meta[i,]))

sort(vec_max_cor, decreasing = T)
# max cor is now 0.7191081
```


```{r}
vec_min_cor = sapply(1:nrow(mat_cor_meta), function(i) min(mat_cor_meta[i,]))

sort(vec_min_cor, decreasing = F)
# min cor is now -0.17439600
```

plot

NB : colors here are hard to distinguish when close to 1

```{r}
col3 <- colorRampPalette(c("blue", "white", "red"))

pdf(file = paste0("/projects/jonatan/pub-perslab/18-liver-wgcna/plots/", prefixData, "_", prefixRun, "_", prefixRun_WGCNA, "_corrplot_meta_modules_", flagDate,".pdf"), width = 6, height=4)

p <- corrplot::corrplot(mat_cor_meta, 
                        method = "shade", 
                        col = col3(50),
                        type = "lower", 
                        diag = F, 
                        mar= c(2, 2, 3, 2), # c(bottom, left, top, right) 
                        order = "original", 
                        tl.cex=0.7,
                        cl.cex=0.6)

dev.off()
```

## write files to disk 


```{r}
fwrite(dt_geneMod_perslab, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_geneMod.csv.gz", compress="gzip")
```

<!-- ```{r} -->
<!-- fwrite(dt_geneMod_gerhard2018, file = "/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_gerhard2018_wgcna3_geneMod.csv.gz", compress="gzip") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- fwrite(dt_geneMod_moylan2013, file = "/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_moylan2013_wgcna1_geneMod.csv.gz", compress="gzip") -->
<!-- ``` -->

<!-- write out module embeddings matrix -->

<!-- ```{r} -->
<!-- dt_embeddings_mod = data.table("run_accession" = rownames(mat_sc_mod_embed_gerhard2018), mat_sc_mod_embed_gerhard2018) -->
<!-- fwrite(dt_embeddings_mod, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_mod_embed_gerhard2018.csv.gz", compress="gzip") -->
<!-- ``` -->

write out meta-module embeddings matrix

```{r}
dt_embeddings_mod_meta = data.table("run_accession"=rownames(mat_embed_meta), mat_embed_meta)
fwrite(dt_embeddings_mod_meta, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_modmeta_embed_gerhard2018.csv.gz", compress="gzip")
```

write out module-metamodule dict

```{r}
dict = dt_geneMod_perslab[,.(module, module_renamed, module_meta)]
```

```{r}
dict = dict[!duplicated(module_renamed) & !is.na(module_renamed) & nchar(module_renamed)>0]
```

```{r}
openxlsx::write.xlsx(x=dict, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_metamod_dict.xlsx")
```

next: 
liver_module_GERR.Rmd
liver_module_gprofiler2.Rmd
liver_module_plots.Rmd
liver_metamodule_GERR.Rmd
liver_metamodule_association_gerhard2018.Rmd
liver_metamodule_association_moylan2013.Rmd
