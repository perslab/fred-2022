---
title: 'Liver - merge gene modules based on co-expression and shared correlations with disease status in bulk (Gerhard) '
author: "Jon Thompson, Pers lab, rkm916 at ku dot dk"
date: "`r Sys.time()`" 
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
params: 
  date: !r substr(gsub("-","",as.character(Sys.Date())),3,1000)
  randomSeed: !r 12345
  pValThreshold: !r 0.05
  pAdjMethod: "BH"
# output:
#   html_notebook:
#     df_print: paged
#     number_sections: yes
#     toc: yes
#     toc_depth: 3
#     toc_float: yes
#   html_document:
#     df_print: paged
#     number_sections: yes
#     toc: yes
#     toc_depth: 3
#     toc_float: yes
---

# Setup

## Load packages

```{r}
#ipak(c("Seurat", "dplyr", "ggplot2", "Matrix", "parallel", "readr", "tidyr"))
#library("Seurat")

library("data.table")
library("Matrix")
library("parallel")
#library("tidyverse")
library("AUCell")
library("here")
library("boot")
library("magrittr")
library("WGCNA")
```

## source utility functions

```{r}
source(here("/perslab-sc-library", "utility_functions.R"))
source(here("perslab-sc-library", "functions_sc.R"))
```

## Set options

```{r}
options(stringsAsFactors = F, 
        use="pairwise.complete.obs", 
        warn=1, 
        verbose=F,
        boot.parallel="multicore", # see ?boot: each worker process inherits the environment of the current session, including the workspace and the loaded namespaces and attached packages (but not the random number seed: see below). 
        boot.ncpus = 20,
        mc.cores=40 # for parallel computation
        ) 

RNGkind("L'Ecuyer-CMRG")
# ?boot
# For most of the boot methods the resampling is done in the master process, but not if simple = TRUE nor sim = "parametric". In those cases (or where statistic itself uses random numbers), more care is needed if the results need to be reproducible. Resampling is done in the worker processes by censboot(sim = "wierd") and by most of the schemes in tsboot (the exceptions being sim == "fixed" and sim == "geom" with the default ran.gen).
# 
# Where random-number generation is done in the worker processes, the default behaviour is that each worker chooses a separate seed, non-reproducibly. However, with parallel = "multicore" or parallel = "snow" using the default cluster, a second approach is used if RNGkind("L'Ecuyer-CMRG") has been selected. In that approach each worker gets a different subsequence of the RNG stream based on the seed at the time the worker is spawned and so the results will be reproducible if ncpus is unchanged, and for parallel = "multicore" if parallel::mc.reset.stream() is called: see the examples for mclapply. 

# data.table
setDTthreads(threads = NULL, 
             restore_after_fork = NULL)
getDTthreads()
```

## Set constants

```{r}
randomSeed = 12345
set.seed(randomSeed)
flagDate =substr(gsub("-","",as.character(Sys.Date())),3,1000)

distmethod = "euclidian"
hclustmethod = "average"
```


generic project constants 

```{r}
prefixData = "liver_perslab_int"
prefixRun = "seurat_7"
prefixRun_WGCNA = "wgcna3"

dirWGCNA_outs = "/projects/jonatan/pub-perslab/18-liver-wgcna/"
dirWGCNA_plots = paste0(dirWGCNA_outs, "plots/" )
dirWGCNA_RObjects = paste0(dirWGCNA_outs, "RObjects/" )
dirWGCNA_tables = paste0(dirWGCNA_outs, "tables/" )

colGeneWeights = "pkMs"
colGeneNames = "genes"
colModule = "module_pres"
colCellCluster = "cell_cluster_pres"
# naming convention:
# <prefixData>_<prefixRun>_<prefixOut>_<outputType>_<params>_<params>_..._<date>.pdf

```

## load data

```{r}
dt_datExpr <- fread(here("data", "liver_gerhard2018_norm.counts.csv.gz"))
```

```{r}
dt_metadata <- fread(here("data", "liver_gerhard2018_patient_metadata_qc.csv.gz"))
```

load data.table with information on module and cell type of origin

```{r}
path_geneMod_perslab_merged <- paste0(dirWGCNA_tables,prefixData, "_",prefixRun_WGCNA,"_geneMod_merged_200325.csv.gz")
  
dt_geneMod_perslab_merged <- fread(path_geneMod_perslab_merged)

head(dt_geneMod_perslab_merged)
```


<!-- ```{r} -->
<!-- path_geneMod_gerhard2018_merged <- paste0(dirWGCNA_tables,"liver_gerhard2018_wgcna3_geneMod_merged_200325.csv.gz") -->

<!-- dt_geneMod_gerhard2018_merged <- fread(path_geneMod_gerhard2018_merged) -->

<!-- head(dt_geneMod_gerhard2018_merged) -->
<!-- ``` -->

# analysis

## Compute module co-expression 

### compute module embeddings in bulk data

<!-- ```{r} -->
<!-- dt_geneMod_merged = rbindlist(list(dt_geneMod_gerhard2018_merged, dt_geneMod_perslab_merged)) -->
<!-- ``` -->


```{r}
dt_geneMod_merged = dt_geneMod_perslab_merged
```

```{r}
dt_geneMod_merged[[colModule]] %>% unique -> vec_mods

vec_mods <- vec_mods[!is.na(vec_mods) & nchar(vec_mods)>0]

list_genesets = lapply(vec_mods, function(mod) {
  condition = quote(dt_geneMod_merged[[colModule]]==mod)
  vec_mod_genes = dt_geneMod_merged[eval(condition), ..colGeneNames, ][[1]] %>% unique
  # filter out moduke genes absent in expression data
  vec_idxRow <- match(vec_mod_genes, dt_datExpr[,gene])
  vec_mod_genes <- vec_mod_genes[!is.na(vec_idxRow)]
  return(vec_mod_genes)
})

names(list_genesets) = vec_mods
```

compute AUC  

```{r}
mat_datExpr <- as.matrix(dt_datExpr[,-1])
rownames(mat_datExpr) = dt_datExpr$gene
```

How many genes are generally non-zero?

It is important to check that most cells have at least the number of expressed/detected genes that are going to be used to calculate the AUC (aucMaxRank in calcAUC())

```{r}
median(colSums(mat_datExpr>0)/nrow(mat_datExpr))

# [1] 0.691221
```

```{r}
min(colSums(mat_datExpr>0)/nrow(mat_datExpr))

# [1] 0.6008318
```

compute gene-rankings for each sample

```{r}

# For each cell, the genes are ranked from highest to lowest value.
samples_rankings <- AUCell_buildRankings(mat_datExpr, plotStats = T)

```

Calculate enrichment for the gene signatures (AUC)
Aibar et al, SCENIC: single-cell regulatory network inference and clustering, Nature Methods (2017)
https://www-nature-com.ep.fjernadgang.kb.dk/articles/nmeth.4463

In brief, the scoring method is based on a recovery analysis where the x-axis (Supplementary Fig. 1c) is the ranking of all genes based on expression level (genes with the same expression value, e.g., '0', are randomly sorted); and the y-axis is the number of genes recovered from the input set

```{r}
# Compute 'Area Under the Cell' for each geneset.
samples_AUC <- AUCell_calcAUC(list_genesets, 
                              samples_rankings, 
                              aucMaxRank=nrow(samples_rankings)*0.45,
                              #nCores = 10, 
                              verbose = T)

```

visualise 

```{r}
list_p = AUCell::AUCell_plotHist(cellsAUC = samples_AUC)
```

```{r}
names(list_p)
```

```{r}
plot(list_p[["gerhard2018_honeydew"]])
```

the honeydew module appears to consist of genes that are all very lowly expressed, and hence the AUC zero, unless we take into account more that the top 0.4 genes in each sample. 

However this would go into non-expressed genes, in some samples.

This points to a limitation of AUC: it cannot be used for modules of genes that are very lowly expressed, since they will nearly always fall outside the envelope set by `aucMaxRank`
```{r}
plot(list_p[["perslab_lightpink1"]])
```

```{r}
plot(list_p[["perslab_darkseagreen2"]])
```

```{r}
plot(list_p[["perslab_lightgoldenrodyellow"]])
```

most module AUCs are thick-tailed (left or right) Normal distributions

```{r}
mat_AUC = getAUC(samples_AUC) %>% t
```

### also compute module embeddings as weighted sums of scaled expression data

>>> THE FOLLOWING HAS BEEN COPIED TO NOTEBOOK liver_module_embed_in_bulk.Rmd M<<<

```{r}
mat_datExpr_log <- mat_datExpr+1 %>% log2
```

filter out genes with zero sd

```{r}
vec_sd = apply(mat_datExpr_log, MARGIN=1, FUN = sd)
```

```{r}
any(vec_sd==0)
#[1] TRUE 
```

```{r}
mat_datExpr_log <- mat_datExpr_log[vec_sd!=0,]
```

```{r}
mat_datExpr_log_scaled = t(mat_datExpr_log) %>% scale %>% t 
```

```{r}
any(is.na(mat_datExpr_log_scaled))
# [1] FALSE
```

```{r}
mat_embed <- sapply(vec_mods, function(mod) {

  # get gene weights
  condition = quote(dt_geneMod_merged[[colModule]]==mod)
  vec_pkMs <- dt_geneMod_merged[eval(condition), pkMs,]

  # normalize module gene weights to sum to 1
  vec_pkMs <- vec_pkMs/sum(vec_pkMs)

  # find corresponding rows of the expression matrix
  vec_idxRow <- match(dt_geneMod_merged[eval(condition), ..colGeneNames, ][[1]], rownames(mat_datExpr_log_scaled))

  # filter out mis-matches
  vec_pkMs <- vec_pkMs[!is.na(vec_idxRow)]
  vec_idxRow <- vec_idxRow[!is.na(vec_idxRow)]

  # compute weighted sum of normalized expression
  mat_datExpr_log_scaled[vec_idxRow,] %>% as.matrix -> mat_sub
  
  if (nrow(mat_sub)==0) {
    stop(paste0(mod, ": no module genes found in datExpr"))
  } else if (nrow(mat_sub)>0 & nrow(mat_sub)<5) {
    warning(paste0(mod, ": only ", nrow(mat_sub), " module genes detected"))
  }
  vec_pkMs %*% mat_sub

})

rownames(mat_embed) <- colnames(mat_datExpr_log_scaled)

mat_embed[0:4,0:4]
```

#### scale module embeddings to z-scores
(for using euclidian distance and for linear models)

```{r}
mat_embed_scaled = scale(mat_embed)
```

### Compare scaled embeddings with AUC

```{r}
all.equal(colnames(mat_AUC), colnames(mat_embed_scaled))
```

```{r}
mat_cor_AUC_embed <- cor(mat_AUC, mat_embed, use="pairwise.complete.obs")
```

get diagonal

```{r}
vec_cor_AUD_embed_diag = sapply(1:nrow(mat_cor_AUC_embed), function(i) mat_cor_AUC_embed[i,i])

summary(vec_cor_AUD_embed_diag)
```

overall, we see a good correspondence between the two methods: a median correlation of 0.85!

Since we know that AUC does badly on lowly expressed genes, we better go with the scaled(log(expr)) measure.

### check module-module correlations

```{r}
mat_cor = cor(mat_embed_scaled)
```

plot correlation

```{r}
col3 <- colorRampPalette(c("blue", "white", "red"))

p <- corrplot::corrplot(mat_cor, 
                        method = "shade", 
                        col = col3(50),
                        type = "lower", 
                        diag = F, 
                        order = "hclust", 
                        tl.cex=0.5)
```

### cluster and merge modules

distance matrix 

```{r}
mat_dist <- dist(t(mat_embed_scaled), method= distmethod)
```

hiearchical clustering 

```{r}
hclustTree = hclust(d=mat_dist, method=hclustmethod)
```

```{r}
cutree = cutreeHybrid(dendro = hclustTree, 
                       distM = as.matrix(mat_dist),
                       minClusterSize = 0,
                       deepSplit=0, 
                       pamStage=F,
                       #pamRespectsDendro=T,
                       verbose=T)
```

0 means unassigned, but in this case we want to keep singletons as their own cluster

```{r}
n_singletons = sum(cutree$labels==0)
vec_singleton_labels = (max(cutree$labels)+1):(max(cutree$labels)+n_singletons)
vec_metalabels = cutree$labels
vec_metalabels[vec_metalabels==0] = vec_singleton_labels
```

```{r}
vec_mods = hclustTree$labels
names(vec_mods) = paste0("metamodule_",vec_metalabels)

vec_mods[order(names(vec_mods))]
```

```{r}
vec_mods_meta = unique(names(vec_mods))
```

# Do meta modules still overlap?
```{r}
list_geneWeights_meta = lapply(vec_mods_meta, function(mod) {
    vec_out =dt_geneMod_merged[[colGeneWeights]][dt_geneMod_merged$module_meta==mod] 
    names(vec_out) <- dt_geneMod_merged[[colGeneNames]][dt_geneMod_merged$module_meta==mod]
    return(vec_out)
  })
names(list_geneWeights)=vec_mods_meta
  
mat_overlap_meta = sapply(list_geneWeights_meta, function(geneWeights) {
    sapply(list_geneWeights_meta, function(geneWeightsOther) {
      base::intersect(x=names(geneWeights), y=names(geneWeightsOther)) %>% length %>% '/'(length(geneWeights))
    }, simplify=T)
  })

mat_overlap_meta <- mat_overlap_meta-diag(1, nrow=nrow(mat_overlap_meta))
```

```{r}
max(mat_overlap_meta, na.rm = T)
# [1] 0.2268908
```


### visualise merged modules on correlation matrix

```{r}
all.equal(vec_mods, colnames(mat_cor))
# [1] "names for target but not for current"
```

```{r}
mat_cor_renamed <- mat_cor
colnames(mat_cor_renamed) <- rownames(mat_cor_renamed) <- paste0(names(vec_mods), "_", vec_mods)
```

```{r}
col3 <- colorRampPalette(c("blue", "white", "red"))

pdf(file = here("plots", paste0(prefixData, "_", prefixRun, "_", prefixRun_WGCNA, "_corrplot_mod_metalabels_", flagDate,".pdf")), width = 14, height=14)

p <- corrplot::corrplot(mat_cor_renamed, 
                        method = "shade", 
                        col = col3(50),
                        type = "lower", 
                        diag = F, 
                        order = "hclust", 
                        tl.cex=0.8)

dev.off()
```

### add new metamodule labels to module data tables

```{r}
dt_geneMod_perslab_merged$module_meta = names(vec_mods)[match(dt_geneMod_perslab_merged[[colModule]], vec_mods)]

dt_geneMod_perslab_merged$cell_cluster_meta = ifelse(!is.na(dt_geneMod_perslab_merged$module_meta),  dt_geneMod_perslab_merged[[colCellCluster]],NA_character_)
```

```{r}
dt_geneMod_gerhard2018_merged$module_meta = names(vec_mods)[match(dt_geneMod_gerhard2018_merged[[colModule]], vec_mods)]

dt_geneMod_gerhard2018_merged$cell_cluster_meta = ifelse(!is.na(dt_geneMod_gerhard2018_merged$module_meta),  dt_geneMod_gerhard2018_merged[[colCellCluster]],NA_character_)
```


### check how much modules assigned to a given meta-module overlap in terms of genes

```{r}
fun = function(geneWeights) {
  sapply(list_geneWeights, function(geneWeightsOther) {
    base::intersect(x=names(geneWeights), y=names(geneWeightsOther)) %>% length %>% '/'(length(geneWeights))
  }, simplify=T)
}
```

```{r}
list_mat_overlaps = lapply(vec_mods_meta, function(mod_meta) {
  
  vec_mods_in_mod_meta = vec_mods[names(vec_mods)==mod_meta]
  
  names(vec_mods_in_mod_meta) = NULL
  
  list_geneWeights = lapply(vec_mods_in_mod_meta, function(mod) {
    vec_out =dt_geneMod_merged[[colGeneWeights]][dt_geneMod_merged$module_pres==mod] 
    names(vec_out) <- dt_geneMod_merged[[colGeneNames]][dt_geneMod_merged$module_pres==mod]
    return(vec_out)
  })
  
  names(list_geneWeights)=vec_mods_in_mod_meta
  
  mat_overlap = sapply(list_geneWeights, function(geneWeights) {
    sapply(list_geneWeights, function(geneWeightsOther) {
      base::intersect(x=names(geneWeights), y=names(geneWeightsOther)) %>% length %>% '/'(length(geneWeights))
    }, simplify=T)
  })
  
  return(mat_overlap)
})

names(list_mat_overlaps) = vec_mods_meta

list_mat_overlaps
```

```{r}
sapply(list_mat_overlaps, median)
```

Some meta-modules consist of highly overlapping modules, others are fairly distinct.

## compute meta-module embeddings

```{r}
mat_embed_meta = sapply(vec_mods_meta, function(mod_meta) {
  vec_mods_in_mod_meta = vec_mods[names(vec_mods)==mod_meta]
  mat_tmp = mat_embed_scaled[,vec_mods_in_mod_meta]
  if (!is.null(dim(mat_tmp))) {
    mat_tmp %>% rowMeans
  } else {
    mat_tmp
  }
})

mat_embed_meta[0:3,0:3]
```

### check meta-module meta-module correlations

```{r}
mat_cor_meta = cor(mat_embed_meta)
```

```{r}
mat_cor_meta = mat_cor_meta - diag(x = 1, nrow=nrow(mat_cor_meta))
```

```{r}
vec_max_cor = sapply(1:nrow(mat_cor_meta), function(i) max(mat_cor_meta[i,]))

sort(vec_max_cor, decreasing = T)
# max cor is now 0.76
```

plot

NB : colors here are hard to distinguish when close to 1

```{r}
col3 <- colorRampPalette(c("blue", "white", "red"))

pdf(file = here("plots", paste0(prefixData, "_", prefixRun, "_", prefixRun_WGCNA, "_corrplot_meta_modules_", flagDate,".pdf")), width = 14, height=14)

p <- corrplot::corrplot(mat_cor_meta, 
                        method = "shade", 
                        col = col3(50),
                        type = "lower", 
                        diag = F, 
                        order = "hclust", 
                        tl.cex=0.5)

dev.off()
```

```{r}
fwrite(dt_geneMod_gerhard2018_merged, file = "/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_gerhard2018_wgcna3_geneMod_merged_200325.csv.gz", compress="gzip")
```

```{r}
fwrite(dt_geneMod_perslab_merged, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_geneMod_merged_200325.csv.gz", compress="gzip")
```

write out module embeddings matrix

```{r}
dt_embeddings_mod = data.table("run_accession" = rownames(mat_embed_scaled), mat_embed_scaled)
fwrite(dt_embeddings_mod, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_mod_embed_gerhard2018.csv.gz", compress="gzip")
```

write out meta-module embeddings matrix

```{r}
dt_embeddings_mod_meta = data.table("run_accession"=rownames(mat_embed_meta), mat_embed_meta)
fwrite(dt_embeddings_mod_meta, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_modmeta_embed_gerhard2018.csv.gz", compress="gzip")
```

write out module-metamodule dict

```{r}
dict = dt_geneMod_merged[,.(cell_cluster_pres, module_pres, module_meta)]
```

```{r}
dict = dict[!duplicated(module_pres) & !is.na(module_pres) & nchar(module_pres)>0]
```

```{r}
openxlsx::write.xlsx(x=dict, file="/projects/jonatan/pub-perslab/18-liver-wgcna/tables/liver_perslab_int_wgcna3_metamod_dict.xlsx")
```

